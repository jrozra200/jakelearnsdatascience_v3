---
title: "Generating Fractals in R"
author: Jacob Rozran
date: '2020-11-25'
draft: yes
slug: generating-fractals-in-r
summaryImage: "roc_curve.jpg"
categories:
- Data Visualization
- Fractals
- R
tags:
- data visualization
- fractals
- R
---

### INTRODUCTION

Something.

### SIERPINKSKI TRIANGLE

> Start with an equilateral triangle and a point chosen at random from the interior of that triangle. Label one vertex 1, 2, a second vertex 3, 4, and the last vertex 5, 6. Roll a die to pick a vertex. Place a dot at the point halfway between the roll-selected vertex and the point you chose. Now consider this new dot as a starting point to do this experiment once again. Roll the die to pick a new vertex. Place a dot at the point halfway between the last point and the most recent roll-selected vertex. Continue this procedure. What does the shape of the collection of dots look like?

```{r sierpinski_triangle, warning = FALSE, message = FALSE, out.width = "100%", echo = FALSE}
library(ggplot2)

## CREATE THE TRIANGLE WITH SIDES OF LENGTH a, CREATING n POINTS, AND        ##
## STARTING POINT AT (startx, starty)                                        ##
createTriange <- function(a = 10, n = 100000, startx = a / 2, 
                          starty = sqrt(3) * a / 4){
        
        ## ESTABLISH THE CORNERS OF THE TRIANGLE                             ##
        ## corner1 IS THE FIRST POINT AT THE ORIGIN; corner2 IS THE SECOND   ##
        ## POINT AT A DISTANCE OF a FROM corner1 AND HALFWAY (ON THE X AXIS) ##
        ## BETWEEN corner1 AND corner3; corner3 IS ON THE X AXIS A DISTANCE  ##
        ## OF a FROM corner1 and corner2                                     ##
        corner1 <- data.frame(x = 0, y = 0) 
        corner2 <- data.frame(x = a / 2, y = sqrt(3) * a / 2)
        corner3 <- data.frame(x = a, y = 0) 
        
        ## CREATE THE STARTING POINT                                         ##
        starting_point <- data.frame(x = startx, y = starty)
        
        ## ADD THE ESTABLISHED POINTS TO THE all_points DATA FRAME - THESE   ##
        ## WILL BE PLOTTED WILL ALL OF THE OTHER POINTS THAT ARE CREATED     ##
        all_points <- data.frame(starting_point)
        
        ## LOOP TO CREATE n POINTS                                           ##
        for(i in 1:n){
                ## CREATE A RANDOM NUMBER BETWEEN 1 AND 4 (ONE FOR EACH      ##
                ## CORNER)                                                   ##
                rand_num <- sample(1:3, 1)
                
                ## PICK A CORNER TO GO TOWARDS BASED ON THE RANDOM NUMBER    ##
                tmp_corn <- if(rand_num == 1){
                        corner1
                } else if(rand_num == 2){
                        corner2
                } else {
                        corner3
                }
                
                ## FIND THE DISTANCE THAT IS HALFWAY BETWEEN THE CORNER AND  ##
                ## POINT WE ARE CURRENTLY AT                                 ##
                tmp_dist <- sqrt((all_points$x[i] - tmp_corn$x)^2 + (all_points$y[i] - tmp_corn$y)^2) / 2
                
                ## FIND THE SLOPE FROM THE CURRENT POINT TO THE CORNER POINT ##
                tmp_slope <- (all_points$y[i] - tmp_corn$y) / (all_points$x[i] - tmp_corn$x)
                
                ## CREATE THE DIVIDEND FOR THE EQUATIONS BELOW               ##
                tmp_r <- sqrt(1 + (tmp_slope)^2)
                
                ## FIND THE NEW VALUE OF X (ADDING OR SUBTRACTING DEPENDING  ##
                ## ON WHERE THE POINT IS IN REGARDS TO WHERE IT IS GOING)    ##
                x <- if(all_points$x[i] < tmp_corn$x) {
                        all_points$x[i] + (tmp_dist / tmp_r)
                } else if(all_points$x[i] > tmp_corn$x){
                        all_points$x[i] - (tmp_dist / tmp_r)
                } else {
                        all_points$x[i]
                }
                
                ## FIND THE NEW VALUE OF Y (ADDING OR SUBTRACTING DEPENDING  ##
                ## ON WHERE THE POINT IS IN REGARDS TO WHERE IT IS GOING)    ##
                y <- if ((all_points$y[i] >= tmp_corn$y) & (all_points$x[i] 
                                                            >= tmp_corn$x)){
                        all_points$y[i] - (tmp_dist * tmp_slope / tmp_r)
                } else if ((all_points$y[i] >= tmp_corn$y) & (all_points$x[i] 
                                                              < tmp_corn$x)){
                        all_points$y[i] + (tmp_dist * tmp_slope / tmp_r)
                } else if ((all_points$y[i] < tmp_corn$y) & (all_points$x[i] 
                                                             >= tmp_corn$x)){
                        all_points$y[i] - (tmp_dist * tmp_slope / tmp_r)        
                } else {
                        all_points$y[i] + (tmp_dist * tmp_slope / tmp_r)
                }
                
                ## PUT X AND Y TOGETHER IN THE NEW POINT                     ##
                tmp_point <- c(x, y)
                
                ## ADD THE NEW POINT TO THE FRAME OF ALL POINTS              ##
                all_points <- rbind(all_points, tmp_point)
        }
        
        ## ADD THE CORNERS TO THE LIST OF POINTS TO BE PLOTTED               ##
        all_points <- rbind(all_points, corner1, corner2, corner3)
        
        ## PLOT THE POINTS                                                   ##
        ggplot(data = all_points, aes(x = x, y = y)) + 
            geom_point(color = "light blue", shape = ".") +
            xlab(element_blank()) +
            ylab(element_blank()) + 
            theme(axis.text = element_blank(), axis.ticks = element_blank(), 
                  panel.background = element_rect(fill = "white"))
}

createTriange()
```

### SIERPINKSKI CARPET

After talking with my professor, Dr. Levitan - it turns out you can get something 
equally awesome as the Sierpinski triangle with a square; you just need to make 
a few changes (say this with a voice of authority and calm knowingness):

> Instead of 3 points to move to, you need 8 points: the 4 corners of a specified square and the midpoints between each side. Also, instead of taking the midpoint of your move to the specified location, you need to take the tripoint (division by 3 instead of 2).

This is called a [Sierpinski Carpet](https://en.wikipedia.org/wiki/Sierpinski_carpet) 
- a fractal of squares (as opposed to a fractal of equilateral triangles in the 
graph above). You can see in both the triangle and square that the same pattern 
is repeated time and again in smaller and smaller increments.

I updated my R script and voila - MORE BEAUTIFUL MATH! 

``` {r sierpinski_carpet, warning = FALSE, message = FALSE, out.width = "100%", echo = FALSE}
## CREATE THE SQUARE WITH SIDES OF LENGTH a, CREATING n POINTS, AND          ##
## STARTING POINT AT (startx, starty)                                        ##
createSquare <- function(a = 10, n = 100000, startx = a / 2, 
                          starty = a / 2){
        
        ## ESTABLISH THE CORNERS OF THE SQUARE                               ##
        ## corner1 IS THE FIRST POINT AT THE ORIGIN; corner2 IS THE SECOND   ##
        ## POINT AT (0, a), corner3 IS THE THIRD POINT AT (a, a), AND        ##
        ## CORNER 4 IS THE LAST POINT AT (a, 0)                              ##
        corner1 <- data.frame(x = 0, y = 0) 
        corner2 <- data.frame(x = 0, y = a)
        corner3 <- data.frame(x = a, y = a) 
        corner4 <- data.frame(x = a, y = 0)
        midpoint1 <- data.frame(x = 0, y = a / 2)
        midpoint2 <- data.frame(x = a / 2, y = a)
        midpoint3 <- data.frame(x = a, y = a / 2)
        midpoint4 <- data.frame(x = a / 2, y = 0)
        
        ## CREATE THE STARTING POINT                                         ##
        starting_point <- data.frame(x = startx, y = starty)
        
        ## ADD THE ESTABLISHED POINTS TO THE all_points DATA FRAME - THESE   ##
        ## WILL BE PLOTTED WILL ALL OF THE OTHER POINTS THAT ARE CREATED     ##
        all_points <- data.frame(starting_point)
        
        ## LOOP TO CREATE n POINTS                                           ##
        for(i in 1:n){
                ## CREATE A RANDOM NUMBER BETWEEN 1 AND 4 (ONE FOR EACH      ##
                ## CORNER)                                                   ##
                rand_num <- sample(1:8, 1)
                
                ## PICK A CORNER TO GO TOWARDS BASED ON THE RANDOM NUMBER    ##
                tmp_corn <- if (rand_num == 1) { 
                        corner1
                } else if (rand_num == 2) {
                        corner2
                } else if (rand_num == 3) {
                        corner3
                } else if (rand_num == 4) {
                        corner4
                } else if (rand_num == 5) {
                        midpoint1
                } else if (rand_num == 6) {
                        midpoint2
                } else if (rand_num == 7) {
                        midpoint3
                } else{
                        midpoint4
                }
                
                ## FIND THE DISTANCE THAT IS HALFWAY BETWEEN THE CORNER AND  ##
                ## POINT WE ARE CURRENTLY AT                                 ##
                tmp_dist <- sqrt((all_points$x[i] - tmp_corn$x)^2 + (all_points$y[i] - tmp_corn$y)^2) * (2 / 3)
                
                ## FIND THE SLOPE FROM THE CURRENT POINT TO THE CORNER POINT ##
                tmp_slope <- (all_points$y[i] - tmp_corn$y) / (all_points$x[i] - tmp_corn$x)
                
                ## CREATE THE DIVIDEND FOR THE EQUATIONS BELOW               ##
                tmp_r <- sqrt(1 + (tmp_slope)^2)
                
                ## FIND THE NEW VALUE OF X (ADDING OR SUBTRACTING DEPENDING  ##
                ## ON WHERE THE POINT IS IN REGARDS TO WHERE IT IS GOING)    ##
                x <- if(all_points$x[i] < tmp_corn$x) {
                        all_points$x[i] + (tmp_dist / tmp_r)
                } else if(all_points$x[i] > tmp_corn$x){
                        all_points$x[i] - (tmp_dist / tmp_r)
                } else {
                        all_points$x[i]
                }
                
                ## FIND THE NEW VALUE OF Y (ADDING OR SUBTRACTING DEPENDING  ##
                ## ON WHERE THE POINT IS IN REGARDS TO WHERE IT IS GOING)    ##
                y <- if ((all_points$y[i] >= tmp_corn$y) & (all_points$x[i] 
                                                            >= tmp_corn$x)){
                        all_points$y[i] - (tmp_dist * tmp_slope / tmp_r)
                } else if ((all_points$y[i] >= tmp_corn$y) & (all_points$x[i] 
                                                              < tmp_corn$x)){
                        all_points$y[i] + (tmp_dist * tmp_slope / tmp_r)
                } else if ((all_points$y[i] < tmp_corn$y) & (all_points$x[i] 
                                                             >= tmp_corn$x)){
                        all_points$y[i] - (tmp_dist * tmp_slope / tmp_r)        
                } else {
                        all_points$y[i] + (tmp_dist * tmp_slope / tmp_r)
                }
                
                ## PUT X AND Y TOGETHER IN THE NEW POINT                     ##
                tmp_point <- c(x, y)
                
                ## ADD THE NEW POINT TO THE FRAME OF ALL POINTS              ##
                all_points <- rbind(all_points, tmp_point)
        }
        
        ## ADD THE CORNERS TO THE LIST OF POINTS TO BE PLOTTED               ##
        all_points <- rbind(all_points, corner1, corner2, corner3, corner4,
                            midpoint1, midpoint2, midpoint3, midpoint4)
        
        ## PLOT THE POINTS                                                   ##
        ggplot(data = all_points, aes(x = x, y = y)) + 
            geom_point(color = "light blue", shape = ".") +
            xlab(element_blank()) +
            ylab(element_blank()) + 
            theme(axis.text = element_blank(), axis.ticks = element_blank(), 
                  panel.background = element_rect(fill = "white"))
}

createSquare()
```

```{r koch_curve, warning = FALSE, message = FALSE, out.width = "100%", echo = FALSE}
### GET IT STARTED
startx <- 0
endx <- 1
    
endy <- 0
starty <- 0
    
iterationx <- (endx - startx) / 1000
iterationy <- (endy - starty) / 1000

middle_third_x_min <- startx + ((endx - startx) / 3)
middle_third_x_max <- startx + (2 * (endx - startx) / 3)

middle_third_y_min <- starty + ((endy - starty) / 3)
middle_third_y_max <- starty + (2 * (endy - starty) / 3)

points <- data.frame(x = startx,
                     y = starty)
for(i in 1:1000){
    if(i == 1){
        newx <- startx + iterationx
        newy <- starty + iterationy
    } else {
        newx <- newx + iterationx
        newy <- newy + iterationy
    }
    
    if(newx > middle_third_x_min & newx < middle_third_x_max) {
        next
    } else {
        tmp <- data.frame(x = newx, y = newy)
        points <- rbind(points, tmp)
    }
}

### THEN GO FROM THERE - STARTING TO SEE THE RECURSIVE PATTERNS, BUT DON'T HAVE 
### MY HEAD WRAPPED AROUND IT YET

startx <- middle_third_x_min
endx <- middle_third_x_min + (middle_third_x_max - middle_third_x_min) / 2

starty <- middle_third_y_min
endy <- cos(60 * pi / 180) / 2

iterationx <- (endx - startx) / 1000
iterationy <- (endy - starty) / 1000

middle_third_x_min <- startx + ((endx - startx) / 3)
middle_third_x_max <- startx + (2 * (endx - startx) / 3)

middle_third_y_min <- starty + ((endy - starty) / 3)
middle_third_y_max <- starty + (2 * (endy - starty) / 3)

for(i in 1:1000){
    if(i == 1){
        newx <- startx + iterationx
        newy <- starty + iterationy
    } else {
        newx <- newx + iterationx
        newy <- newy + iterationy
    }
    
    if(newx > middle_third_x_min & newx < middle_third_x_max) {
        next
    } else {
        tmp <- data.frame(x = newx, y = newy)
        points <- rbind(points, tmp)
    }
}

xdist <- endx - startx
startx <- endx
endx <- startx + xdist

ydist <- endy - starty
starty <- endy
endy <- starty - ydist

iterationx <- (endx - startx) / 1000
iterationy <- (endy - starty) / 1000

middle_third_x_min <- startx + ((endx - startx) / 3)
middle_third_x_max <- startx + (2 * (endx - startx) / 3)

middle_third_y_min <- starty + ((endy - starty) / 3)
middle_third_y_max <- starty + (2 * (endy - starty) / 3)

for(i in 1:1000){
    if(i == 1){
        newx <- startx + iterationx
        newy <- starty + iterationy
    } else {
        newx <- newx + iterationx
        newy <- newy + iterationy
    }
    
    if(newx > middle_third_x_min & newx < middle_third_x_max) {
        next
    } else {
        tmp <- data.frame(x = newx, y = newy)
        points <- rbind(points, tmp)
    }
}


ggplot(points, aes(x, y)) + 
    geom_point(shape = ".") + 
    scale_y_continuous(limits = c(0, 1))
```